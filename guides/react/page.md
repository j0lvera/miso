# Pages

## Body

A Page represents a database table or a screen and their main job is to receive data and pass it to the UI.

The secondary job is to hold the functions that affect the data, e.g., `onSubmit`, `formatData`, etc.

In short, a page holds the business logic of the UI that represent, for example, a page that displays a list of blog posts, will hold functions to:

* Query the data via a regular query or suspense or receive the data as a prop.
* Define a function that will hold the logic to update a blog post by id.
* Define a function that will delete a blog post by id.
* Define a function that will create a new blog post.

Other logic that a Page can contain:

* A modal

### Page body example

```ts
import { match } from 'ts-pattern';

import { Confirm } from '@/components/blocks/confirm.tsx';

import { PostList } from '@/components/features/posts/post.list.tsx';

// These types are generated by Kubb based on the API's Open API schema
import type { CreatePostPayload, UpdatePostPayload } from '@/gen';

// This prevents having multiple `useState`s
const activeModalState = {
  "NONE": "NONE",
  "CREATE_POST": "CREATE_POST",
  "UPDATE_POST": "UPDATE_POST",
  "DELETE_POST": "DELETE_POST",
} as const;

const PostsPage = ({ data }) => {
  const [activeModal, setActiveModal] = useState<activeModal>(activeModalState.NONE);
  
  /**
   * Create a new Post
   *
   * POST /posts
   */
   
  const createPostformId="CREATE_POST_FORM_" + shortId.generate();
   
  const createPost = useMutation({ /* ... */ });
  
  const handleCreatePost = (payload: CreatePostPayload) => {
    createPost.mutate( /* ... */ )
  }
  
  const handleOpenCreateModal = () => {
    setActiveModal(activeModalState.CREATE_POST);
  }
  
  /**
   * Update a Post by ID
   *
   * PUT /posts/$puuid
   */
   
  const updatePostformId="UPDATE_POST_FORM_" + shortId.generate();
    
  const updatePost = useMutation({ /* ... */ })
 
  const handleUpdatePost = (payload: UpdatePostPayload) => {
    updatePost.mutate( /* ... */ )
  }
  
  const handleOpenUpdateModal = (uuid: string) => {
    setActiveModal(activeModalState.UPDATE_POST);
  }
  
  /**
   * Delete a Post by ID
   *
   * DELETE /posts/$puuid
   */
   
   const deletePostformId="DELETE_POST_FORM_" + shortId.generate();
   
   const deletePost = useMutation({ /* ... */ })
  
   const handleDeletePost = (payload: UpdatePostPayload) => {
     deletePost.mutate( /* ... */ )
   }
   
   const handleOpenDeleteModal = (uuid: string) => {
     setActiveModal(activeModalState.DELETE_POST);
   }
  
  return (
    <>
      {match(activeModalState)
        .with(activeModalState.CREATE_POST, () => (
          <Modal formId={createPostformId}>
            <PostForm formId={createPostformId} onSubmit={handleCreatePost} />
          </Modal>
        )
        .with(activeModalState.UPDATE_POST, () => (
          <Modal formId={updatePostformId}>
            <PostForm formId={updatePostformId} onSubmit={handleUpdatePost} />
          </Modal>)
        .with(activeModalState.DELETE_POST, () => (
          <Modal formId={deletePostformId}>
            <Confirm formId={deletePostformId} onConfirm={handleDeletePost} />
          </Modal>)
        .otherwise(() => null)
      )}
      <div>
        <button onClick={handleOpenCreateModal}>Create Post</button>
      </div>
      <div>
        <PostList 
          data={data}
          onEdit={handleOpenUpdateModal}
          onDelete={handleOpenDeleteModal}
        />
      </div>
    </>
  )
};
```

## How to get the data

There are three ways to get the data.

### Using Suspense

This is the recommended way. The router (either React Router or Tanstack Router) will prefetch the data for us and we get it from the cache using suspense. Suspense guarantees that the data is present, so we don’t need logic for missing data, e.g., `data.isLoading`, `data.isError`.

```ts
// `postsQueryOptions()` returns the queryKey and other options
const postsQuery = useSuspenseQuery(postsQueryOptions());
```

### Calling the API directly

Sometimes we need to call the API directly. It’s okay for Page components to do so, but only when necessary.

When we call the API directly using a query, we need to handle missing data logic, i.e., `data.isLoading` and `data.isError`. Always prefer `ts-pattern` when dealing with the loading state.

```ts
const postsQuery = useQuery(postsQueryOptions());

{match(postsQuery)
   .with({ 
     data: P._, // any value
     isError: true, 
     isLoading: P._ , // any value
   }, () => <p>ERROR!</p>)
   .with({ 
     data: P._, , // any value
     isError: false, 
     isLoading: true 
    }, () => <p>Loading...</p>)
   .with({ 
     data: P.not(P.nullish), // ensure data
     isError: false, 
     isLoading: false 
   }, () => <p>{data[0].name}</p>)}
```

### As a prop

In very specific cases, we might get the data directly from the Route component.

```ts
// In this case, the user context was defined in the /app/ route, so we can
// use it here and all child routes coming from /app/.
import { SettingsPage as Page } from "@/components/pages/settings.page.tsx";

export const Route = createFileRoute("/app/settings")({
  component: PageRoute,
});

function PageRoute() {
  const context = Route.useRouteContext();

  return <Page user={context.user} />
}
```

